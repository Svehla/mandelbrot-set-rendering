<!DOCTYPE html>
<html>
<head>
	<style>
	body {
		padding: 0;
		margin: 0;
	}
	</style>
</head>
<body>

	<div>
		<div>
			<div>
				<button onclick="goUp()">goUp</button>
			</div>
			<div>
				<button onclick="goLeft()">goLeft</button>
				<button onclick="goRight()">goRight</button>
			</div>
			<div>
				<button onclick="goDown()">goDown</button>
			</div>
		</div>
		<div>
			<button onclick="zoomIn()">zoomIn</button>
			<button onclick="zoomOut()">zoomOut</button>
		</div>
		<div>
			<button onclick="increaseDetail()">increaseDetail</button>
			<button onclick="decreaseDetail()">decreaseDetail</button>
		</div>
	</div>

<canvas id="myCanvas" width="10" height="10" style="border:1px solid #d3d3d3;">
Your browser does not support the HTML canvas tag.</canvas>


<div id="config"></div>

<script>

// setTimeout(function(){
// 	// window.location.reload();
// }, 3000);


// 4K === 3840 x 2160 pixel
// relevant constants
const width = 400
// const width = 3840
const landscape = false


// this is constant value! 
const UNIT_SQUARE_SIZE_WIDTH_PERCENT = 30

const SCREEN_RATIO_A = 16
const SCREEN_RATIO_B = 9
const screenRation = landscape ? (SCREEN_RATIO_A / SCREEN_RATIO_B) : SCREEN_RATIO_B / SCREEN_RATIO_A
const height = width * screenRation

const appConfig = {
	MAX_ITERATION: 50
}

// all values are base units
const view = {
	// left top coordination 
	// TODO: what about to change it into center points?
	x: -1,
	y: -1,
	squaresPerWidth: 1,
	// x: -2,
	// y: -1,
	// squaresPerWidth: 3,
	ratio: screenRation
}

// computed
const STEP_SIZE = width / 100 * UNIT_SQUARE_SIZE_WIDTH_PERCENT

var c = document.getElementById("myCanvas");
c.width  = width
c.height = height
var ctx = c.getContext("2d");

// utils
const drawLine = (point1, point2, conf) => {
	ctx.strokeStyle = conf.color ?? 'black'
	ctx.lineWidth = conf.width ?? 1

	ctx.beginPath();
	ctx.moveTo(point1.x, point1.y);
	ctx.lineTo(point2.x, point2.y);
	ctx.stroke();
}

const drawDot = (point1, width) => {
	ctx.beginPath();
	ctx.arc(point1.x, point1.y, width, 0, 2 * Math.PI);
	ctx.stroke();
}

const drawCircle = (point1, width) => {
	ctx.beginPath();
	ctx.arc(point1.x, point1.y, width, 0, 2 * Math.PI);
	ctx.stroke();
}

const drawPoint = (point, color = 'black') => {
	drawLine(point, { x: point.x + 1, y: point.y + 1 }, { color, width: 1 })
}

const clearCanvas = () => {
	ctx.clearRect(0, 0, width, height)
}
// ----------------------------------------

// todo: duplicated size with the html code



//// ----------------------------------------
// relative utils

// r = real
// i = imaginary
// c = complex

const rawComplexNum = (real, imaginaryUnit, imaginaryExponential) => {
	return {
		real,
		imaginaryUnit,
		imaginaryExponential,
		// just debug stuffs...
		// toString: () => {
		// 	if (imaginaryUnit === 0) {
		// 		return `${real}`
		// 	}
		// 	return `${real} + ${imaginaryUnit}i^(${imaginaryExponential})`
		// }
	}
}

// TODO: should complex number has imaginary exponential? or it could work out of the box
const complexNum = (real, imaginaryUnit, imaginaryExponential) => 
	normalizeImaginaryPart(rawComplexNum(
		real,
		imaginaryUnit,
		imaginaryExponential,
	))



// does not work for negative exponential numbers
const normalizeImaginaryPart = (c) => {
	const normalizedImaginaryExponent04 = c.imaginaryExponential % 4

	// 0 to 4 is full rotation
	switch (Math.abs(normalizedImaginaryExponent04)) {
		case 0:
			return rawComplexNum(c.real + c.imaginaryUnit, 0, 0)
		case 1:
			return rawComplexNum(c.real, c.imaginaryUnit, 1)
		case 2:
			return rawComplexNum(c.real - c.imaginaryUnit, 0, 0)
		case 3:
			return rawComplexNum(c.real, -c.imaginaryUnit, 1)
	}

}

// works only for raw imaginary numbers
const sumComplexNum = (c1, c2) => {
	const newImaginaryUnit = c1.imaginaryUnit + c2.imaginaryUnit
	return rawComplexNum(
		c1.real + c2.real,
		newImaginaryUnit,
		1
	)
}

/**
 * example
 * c1 and c2 has to be normalized with exponent 0 or 1
 * (a + b)*(c + d) === a*c + a*d + b*c + b*d
 */
const mulComplexNum = (c1, c2) => {
	const s1 = c1.real * c2.real
	const s2 = c1.real * c2.imaginaryUnit
	const s3 = c1.imaginaryUnit * c2.real
	const s4 = c1.imaginaryUnit * c2.imaginaryUnit
	
	// cool vector rotation
	return rawComplexNum(s1 - s4, s2 + s3, 1)

	// const r1 = sumComplexNum(
	// 	// TODO: is 1 at the exponent??? does it care??!!!!
	// 	complexNum(s1, 0, 0),
	// 	complexNum(0, s2, 1),
	// )
	// const r2 = sumComplexNum(
	// 	r1,
	// 	// TODO: is 1 at the exponent??? does it care??!!!!
	// 	complexNum(0, s3, 1),
	// )
	// const r3 = sumComplexNum(
	// 	r2,
	// 	// TODO: is 2 at the exponent??? does it care??!!!!
	// 	complexNum(0, s4, 2),
	// )
	// return r3
}

const pow2ComplexNum = (c1) => {
	return mulComplexNum(c1, c1)
}

const complexZeroZero = complexNum(0, 0, 0)

const mandelbrotIteration = (initValueC) => { 

	let prevValue = initValueC

	for (let i = 0; i < appConfig.MAX_ITERATION; i++) {
		prevValue = sumComplexNum(pow2ComplexNum(prevValue), initValueC)
	}

	return prevValue
}

const delay = (time) => new Promise((res) => setTimeout(res, time))

const normalizeIntoInterval = (val, max, min) => (val - min) / (max - min)

let currentDrawingId = Math.random()

const drawConfig = () => {
	const confEl = document.getElementById('config')
	confEl.innerHTML = `
		<div>
			<div>x: ${view.x}</div>
			<div>y: ${view.y}</div>
			<div>1/zoom: ${view.squaresPerWidth}</div>
			<div>detail: ${appConfig.MAX_ITERATION}</div>
		</div>

	`
}

const drawFullImg = async () => {
	drawConfig()
	let newCurrentDrawingId = Math.random()
	currentDrawingId = newCurrentDrawingId
	clearCanvas()

	console.time('a')

	for (let x = 0; x < width; x++) {
		// kill old drawing processes
		if (currentDrawingId !== newCurrentDrawingId) return

		for (let y = 0; y < height; y++) {

			const relativePointCoords = {
				x: view.x + (view.squaresPerWidth / width * x),
				y: view.y + ((view.squaresPerWidth * view.ratio) / height * y)
			}

			const value = mandelbrotIteration(
				complexNum(
					relativePointCoords.x,
					relativePointCoords.y,
				  1
				),
				{ debugLine: false }
			)

			const colorConstantsSize = 10000
			const pointSize = Math.abs(value.real) + Math.abs(value.imaginaryUnit)

			if (isNaN(pointSize)) {
				drawPoint({ x, y }, `black`)
			} else {
				const h = Math.floor(1 / pointSize * 255)
				const s = Math.floor(100)
				const l = Math.floor(50)
				drawPoint({ x, y }, `hsl(${h}, ${s}%, ${l}%)`)
			}
		}
		// make rendering interactive
		await delay(0)
	}
	console.timeEnd('a')
}

drawFullImg()


const zoomCoefficient = 3

// ------- ui --------
const goRight = () => {
	view.x += view.squaresPerWidth / zoomCoefficient
	drawFullImg()
}

const goLeft = () => {
	view.x -= view.squaresPerWidth / zoomCoefficient
	drawFullImg()
}


const goDown = () => {
	view.y += view.squaresPerWidth / zoomCoefficient
	drawFullImg()
}

const goUp = () => {
	view.y -= view.squaresPerWidth / zoomCoefficient
	drawFullImg()
}

const zoomInPoint = (x, y) => {
	console.log('-------')
	console.log(x, y)
	console.log(y / height)
	// console.log(view.x)
	// console.log(width)
	// console.log(view.squaresPerWidth)

	// i have to move center point! not the left top coordination
	// newXShift
	const squaresPerHeight = view.squaresPerWidth * view.ratio
	const newX = view.x + (view.squaresPerWidth * (x / width)) - (view.squaresPerWidth / 2)
		// height is calculated by ratio...
	const newY = view.y + (squaresPerHeight * (y / height)) - (squaresPerHeight / 2)
	
	console.log('old', view.x, view.y)
	console.log('new', newX, newY )
	console.log(squaresPerHeight, y / height)

	view.x = newX
	view.y = newY

	zoomIn()
	// drawFullImg()
}

const zoomIn = () => {
	appConfig.MAX_ITERATION += 5
	// duplicated code
	const oldSPW = view.squaresPerWidth
	const newSPW = view.squaresPerWidth - (view.squaresPerWidth / zoomCoefficient)
	view.squaresPerWidth = newSPW
	const moveX = (oldSPW - newSPW) / 2
	view.x += moveX
	view.y += moveX * view.ratio
	drawFullImg()
}

const zoomOut = () => {
	appConfig.MAX_ITERATION -= 5
	// duplicated code
	const oldSPW = view.squaresPerWidth
	const newSPW = view.squaresPerWidth + (view.squaresPerWidth / zoomCoefficient)
	view.squaresPerWidth = newSPW
	const moveX = (oldSPW - newSPW) / 2
	view.x += moveX
	view.y += moveX * view.ratio
	drawFullImg()
}

const increaseDetail = () => {
	appConfig.MAX_ITERATION += 10
	drawFullImg()
}

const decreaseDetail = () => {
	appConfig.MAX_ITERATION -= 10
	drawFullImg()
}

document.addEventListener("keydown", e => {
	console.log(e)
	if (e.keyCode == 38) {
		goUp()
  }
  if (e.keyCode == 40) {
		goDown()
  }
  if (e.keyCode == 37) {
		goLeft()
  }
  if (e.keyCode == 39) {
		goRight()
  }
});

c.addEventListener("dblclick", (e) => {
	console.log(e)
	const x = e.offsetX
	const y = e.offsetY

	zoomInPoint(x, y)
});


window.x = {
	goRight,
	goLeft,
	goDown,
	goUp,
	zoomIn,
	zoomOut,
	increaseDetail,
	decreaseDetail,
}




</script>

</body>
</html>