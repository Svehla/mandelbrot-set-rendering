<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<style>
	body {
		padding: 0;
		margin: 0;
	}
	</style>
</head>
<body>



<canvas id="myCanvas" width="10" height="10" style="border:1px solid #d3d3d3;">
Your browser does not support the HTML canvas tag.</canvas>


<div id="config"></div>

<script>

// setTimeout(function(){
// 	// window.location.reload();
// }, 3000);

// --------------------------- canvas utils ---------------------------
const drawLine = (point1, point2, conf) => {
	ctx.strokeStyle = conf.color ?? 'black'
	ctx.lineWidth = conf.width ?? 1

	ctx.beginPath();
	ctx.moveTo(point1.x, point1.y);
	ctx.lineTo(point2.x, point2.y);
	ctx.stroke();
}

const drawDot = (point1, dotWidth) => {
	ctx.beginPath();
	ctx.arc(point1.x, point1.y, dotWidth, 0, 2 * Math.PI);
	ctx.stroke();
}

// is this radius? or radius*2?
const drawCircle = (point1, radius) => {
	ctx.beginPath();
	ctx.arc(point1.x, point1.y, radius, 0, 2 * Math.PI);
	ctx.stroke();
}

const drawPoint = (point, color = 'black', size = 1) => {
	if (size > 1) {
		ctx.fillStyle = color
		ctx.strokeStyle = color
		ctx.fill();
		ctx.beginPath();
		ctx.rect(point.x, point.y, size, size);
		ctx.stroke();
	} else {
		drawLine(point, { x: point.x + size, y: point.y + size }, { color, width: 1 })
	}

}

const clearCanvas = () => {
	ctx.clearRect(0, 0, view.width, view.getHeight())
}

// --------------------------- utils ---------------------------
const delay = (time) => new Promise((res) => setTimeout(res, time))

const normalizeIntoInterval = (val, max, min) => (val - min) / (max - min)

// --------------------------- setup app ---------------------------
const landscape = false
const SCREEN_RATIO_A = 16
const SCREEN_RATIO_B = 9
const screenRation = landscape ? (SCREEN_RATIO_A / SCREEN_RATIO_B) : SCREEN_RATIO_B / SCREEN_RATIO_A
 
const getWindowRatio = () => window.innerHeight / window.innerWidth

// all values are base units
let view = {
	iterationsDetail: 50,
	width: 
	  // window.innerWidth,
	  // 3840, // 4K === 3840 x 2160 pixel
		2**10,
	// TODO: what about to change it into center points?
	x: -1,
	y: -1,
	squaresPerWidth: 1,
	ratio: getWindowRatio(),
	getScale: () => 1, // window.innerWidth / view.width,
	// TODO: hook singleton methods into the object prototype
	getHeight: () => view.width * view.ratio,
	// getHeight: () => view.width * screenRation,
	getSquaresPerHeight: () => view.squaresPerWidth * view.ratio,
}

// override view for debug purposes
// view = {
// 	...view,
//   "iterationsDetail": 755,
//   "width": 950,
//   "x": -0.14412896836551436,
//   "y": -0.6516950488709018,
//   "squaresPerWidth": 0.002283658260521168,
//   "ratio": 0.5625
// }

var c = document.getElementById("myCanvas");
const setCanvasSize = () => {
	c.width  = view.width
	c.height = view.getHeight()
}

setCanvasSize()

var ctx = c.getContext("2d");

// --------------------------- complex numbers ---------------------------

const rawComplexNum = (real, imaginary) => ({
	real,
	imaginary,
})


// /* does not work for negative exponential numbers */
// const normalizeImaginaryPart = (c) => {
// 	const normalizedImaginaryExponent04 = c.imaginaryExponential % 4
// 	// 0 to 4 is full rotation
// 	switch (Math.abs(normalizedImaginaryExponent04)) {
// 		case 0:
// 			return rawComplexNum(c.real + c.imaginary, 0)
// 		case 1:
// 			return rawComplexNum(c.real, c.imaginary)
// 		case 2:
// 			return rawComplexNum(c.real - c.imaginary, 0)
// 		case 3:
// 			return rawComplexNum(c.real, - c.imaginary)
// 	}
// }

// works only for raw imaginary numbers
const sumComplexNum = (c1, c2) => 
	rawComplexNum(
		c1.real + c2.real,
		c1.imaginary + c2.imaginary
	)

/**
 * Example calculation:
 * --------------------
 * imaginary number 1: "a + bi"
 * imaginary number 2: "c + bi"
 * 
 *  (a + bi) * (c + di)
 *   = ac + adi + bci + bi*di // multiple all elements inside of brackets
 *   = ac + adi + bci + bdi^2 // make exponent ^2 of imaginary part
 *   = ac + adi + bci - bd    // simplify ^2 to * -1
 *   = (ac - bd) + (ad + bc)i // final calculation
 */
const multiplyComplexNumbers = (c1, c2) => {
	const ac = c1.real * c2.real
	const adi = c1.real * c2.imaginary
	const bci = c1.imaginary * c2.real
	const bd = c1.imaginary * c2.imaginary
	return rawComplexNum(ac - bd, adi + bci)
}

// --------------------------- mandelbrot calculation ---------------------------

const calcMandelbrotSetPoint = (initValueComplexNum) => { 
	let prevValue = initValueComplexNum

	for (let i = 0; i < view.iterationsDetail; i++) {
		prevValue = sumComplexNum(
			multiplyComplexNumbers(prevValue, prevValue),
			initValueComplexNum
		)
	}

	return prevValue
}

let currentDrawingId = Math.random()

const isOdd = n => n % 2 === 1
// check if GPU could compute it smoothly
const smartIterateMatrixOptimiseHigherResolution = async (newCurrentDrawingId, maxSizeX, maxSizeY, getValFn, stepFn) => {
	// relative or absolute x?




	// TODO: what about exponential growth of time complexity

	// split screen into the the same count of boxes and increase resolution for them
	// based on ratio x/y
	// then calculate spaces between and do not repeat yourself

	if (maxSizeX <= 1) {
		throw new Error('small screen')
	}
	const initBoxSize = 2**5 // px

	// init sq
	let scale = Math.floor(maxSizeX / initBoxSize)
	// let scale = Math.max(maxSizeX, maxSizeY)

	const values = Array.from({ length: maxSizeX }, () => Array.from({ length: maxSizeY }))

	let iterations = 0 
// compute numbers
// then render numbers into the canvas
	while (scale >= 1) {
		console.log(scale)
		// console.log('scale: ', scale)

		for (let x = 0; x < maxSizeX; x = x+scale) {

			for (let y = 0; y < maxSizeY; y = y+scale) {

				if (currentDrawingId !== newCurrentDrawingId) return
				// calc optimisation
				if (scale === 1) {

					values[x][y] = getValFn(x, y, scale)
				}
				if (!isOdd(x) && !isOdd(y)) {
					values[x][y] = getValFn(x, y, scale)
				}
				iterations++

				// TODO: what about to do it by time, not iterations...
				if (iterations > 10000) {
					iterations = 0
					await stepFn()
				}
			}

			// make user be interactive
			// await delay(0)
		}
		// TODO: should i use canvas scale or copy of pixels?
		// then the scale will be just an multiplier integer 1|2|3...
		// render canvas + change scale
		await stepFn()
		scale /= 2
	}

	await stepFn()
}




const drawFullImg = async () => {
	clearCanvas()

	let newCurrentDrawingId = Math.random()
	currentDrawingId = newCurrentDrawingId

	const height = view.getHeight()

	const colorConstantsSize = 10000

	smartIterateMatrixOptimiseHigherResolution(
		newCurrentDrawingId,
		view.width,
		// window.innerWidth,
		height,
		(x, y, scale) => {
			const squaresPerHeight = view.getSquaresPerHeight()
			const relativePointCoords = {
				x: view.x + (view.squaresPerWidth / view.width * x),
				y: view.y + (squaresPerHeight / height * y)
			}

			const value = calcMandelbrotSetPoint(
				rawComplexNum(
					relativePointCoords.x,
					relativePointCoords.y,
				)
			)

			const pointSize = Math.abs(value.real) + Math.abs(value.imaginary)

				// console.log(scale)
			if (isNaN(pointSize)) {
				drawPoint({ x, y }, `black`, scale)
			} else {
				const h = Math.floor(1 / pointSize * 255)
				const s = 100
				const l = 50
				drawPoint({ x, y }, `hsl(${h}, ${s}%, ${l}%)`, scale)
			}

			return value
		},
		async (numbers, scale) => {
			// le.log(numbers)
			// render canvas
			// for ()
			// for (let x = 0; x < numbers.length; x = x+scale) {
			// 	for (let y = 0; y < height; y = y+scale) {

			// 		const value = numbers[x][y]

			// 		const pointSize = Math.abs(value.real) + Math.abs(value.imaginary)

			// 		if (isNaN(pointSize)) {
			// 			drawPoint({ x, y }, `black`, scale)
			// 		} else {
			// 			const h = Math.floor(1 / pointSize * 255)
			// 			const s = 100
			// 			const l = 50
			// 			drawPoint({ x, y }, `hsl(${h}, ${s}%, ${l}%)`, scale)
			// 		}

			// 	}
			// }

			// view.width = numbers.length
			// c.setAttribute("style", `zoom: ${view.getScale()};`);
			await delay(0)
		}
	)


	return 'xd'


	// c.setAttribute("style", `zoom: ${view.getScale()};`);
	// console.time('a')

	// for (let x = 0; x < view.width; x++) {
	// 	// this can kill the old drawing process
	// 	if (currentDrawingId !== newCurrentDrawingId) return

	// 	for (let y = 0; y < height; y++) {

	// 		// TODO: add description
	// 		// this could be method of view class :thinking:
	// 		const squaresPerHeight = view.getSquaresPerHeight()
	// 		const relativePointCoords = {
	// 			x: view.x + (view.squaresPerWidth / view.width * x),
	// 			y: view.y + (squaresPerHeight / height * y)
	// 		}

	// 		const value = calcMandelbrotSetPoint(
	// 			rawComplexNum(
	// 				relativePointCoords.x,
	// 				relativePointCoords.y,
	// 			)
	// 		)

	// 		const colorConstantsSize = 10000
	// 		const pointSize = Math.abs(value.real) + Math.abs(value.imaginary)

	// 		if (isNaN(pointSize)) {
	// 			drawPoint({ x, y }, `black`)
	// 		} else {
	// 			const h = Math.floor(1 / pointSize * 255)
	// 			const s = Math.floor(100)
	// 			const l = Math.floor(50)
	// 			drawPoint({ x, y }, `hsl(${h}, ${s}%, ${l}%)`)
	// 		}
	// 	}
	// 	// make rendering interactive
	// 	// await delay(0)
	// }
	// console.timeEnd('a')
}




// --------------------------- html ui ---------------------------

const ZOOM_STEP_COEFFICIENT = 3

const drawConfig = () => {
	const confEl = document.getElementById('config')
	confEl.innerHTML = `
		<div style="position: absolute; top: 0; left: 0; background: rgba(0, 0, 0, 0.5); color: white">
			${
				''
			// <h4>view state</h4>
			// <pre>
			// 	${JSON.stringify({
			// 	  ...view,
			// 		// computed variable
			// 		computed_scale: view.getScale()
			// 	}, null, 2)}
			// </pre>
			}

			<div>
				<div>
					<div>
						<button onclick="goUp()">↑</button>
						<button onclick="goDown()">↓</button>
						<button onclick="goLeft()">←</button>
						<button onclick="goRight()">→</button>
					</div>
				</div>
				<div>
					<button onclick="zoomIn()">zoom +</button>
					<button onclick="zoomOut()">zoom -</button>
				</div>
			<div>

			${
					// <div>
					// 	Resolution scale (DPI)
					// </div>
					// <input 
					// 	oninput="ahoj"
					// 	type="range" min="1" step="0.1" max="5" value="5" id="resolutionScaleDPI"
					// >
					''
			}

			${
				""
				// <div>
				// 	<div>resolution scale</div>
				// 	<button onclick="increaseResolutionScale()">increase</button>
				// 	<button onclick="decreaseResolutionScale()">decrease </button>
				// </div>

			}

				${
					''
				// <div>
				// 	<div>Depth</div>
				// 	<button onclick="increaseDepth()">increase</button>
				// 	<button onclick="decreaseDepth()">decrease</button>
				// </div>
				}
			</div>

		</div>
	`
}


const goRight = () => {
	view.x += view.squaresPerWidth / ZOOM_STEP_COEFFICIENT
	renderUI()
}

const goLeft = () => {
	view.x -= view.squaresPerWidth / ZOOM_STEP_COEFFICIENT
	renderUI()
}

const goDown = () => {
	view.y += view.squaresPerWidth / ZOOM_STEP_COEFFICIENT
	renderUI()
}

const goUp = () => {
	view.y -= view.squaresPerWidth / ZOOM_STEP_COEFFICIENT
	renderUI()
}

const zoomInPoint = (x, y) => {
	const height = view.getHeight()
	const width = view.width
	const squaresPerHeight = view.getSquaresPerHeight()
	const newX = view.x + (view.squaresPerWidth * (x / width)) - (view.squaresPerWidth / 2)
	const newY = view.y + (squaresPerHeight * (y / height)) - (squaresPerHeight / 2)

	view.x = newX
	view.y = newY
	zoomInLogic()
	renderUI()
}

const ZOOM_ITERATION_DETAIL_STEP = 7
const zoomInLogic = () => {
	view.iterationsDetail += ZOOM_ITERATION_DETAIL_STEP
	// duplicated code
	const oldSPW = view.squaresPerWidth
	const newSPW = view.squaresPerWidth - (view.squaresPerWidth / ZOOM_STEP_COEFFICIENT)
	view.squaresPerWidth = newSPW
	const moveX = (oldSPW - newSPW) / 2
	view.x += moveX
	view.y += moveX * view.ratio
}

const zoomIn = () => {
	zoomInLogic()
	renderUI()
}

const zoomOutLogic = () => {
	view.iterationsDetail -= ZOOM_ITERATION_DETAIL_STEP
	// duplicated code
	const oldSPW = view.squaresPerWidth
	const newSPW = view.squaresPerWidth + (view.squaresPerWidth / ZOOM_STEP_COEFFICIENT)
	view.squaresPerWidth = newSPW
	const moveX = (oldSPW - newSPW) / 2
	view.x += moveX
	view.y += moveX * view.ratio
}

const zoomOut = () => {
	zoomOutLogic()
	renderUI()
}

const ITERATION_DETAIL_STEP = 10
const increaseDepth = () => {
	view.iterationsDetail += ITERATION_DETAIL_STEP
	renderUI()
}

const decreaseDepth = () => {
	view.iterationsDetail -= ITERATION_DETAIL_STEP
	renderUI()
}

const RESOLUTION_STEP = 100

const increaseResolutionScale = () => {
	const widthWidth = window.innerWidth
	view.width += RESOLUTION_STEP
	// does not make sense to have more than 1px per 1px
	// TODO: use Math.min
	if (view.width > widthWidth) {
		view.width = widthWidth
	}
	c.setAttribute("style", `zoom: ${view.getScale()};`);
	setCanvasSize()
	renderUI()
}

const decreaseResolutionScale = () => {
	view.width -= RESOLUTION_STEP
	c.setAttribute("style", `zoom: ${view.getScale()};`);
	setCanvasSize()
	renderUI()
}

document.addEventListener("keydown", e => {
	if (e.keyCode == 38) {
		goUp()
  }
  if (e.keyCode == 40) {
		goDown()
  }
  if (e.keyCode == 37) {
		goLeft()
  }
  if (e.keyCode == 39) {
		goRight()
  }
});

c.addEventListener("dblclick", (e) => {
	const x = e.offsetX / view.getScale()
	const y = e.offsetY / view.getScale()
	zoomInPoint(x, y)
});

window.addEventListener("resize", e => {
	const widthWidth = window.innerWidth

	// TODO: use Math.min
	if (view.width > widthWidth) {
		view.width = widthWidth
	}

	view.ratio = getWindowRatio()
	c.setAttribute("style", `zoom: ${view.getScale()};`);
	setCanvasSize()
	renderUI()
});

const renderUI = () => {
	drawFullImg()
	drawConfig()
}

const initRenderUI = () => {
	c.setAttribute("style", `zoom: ${view.getScale()};`);
	renderUI()
}

renderUI()


</script>

</body>
</html>